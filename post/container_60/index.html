<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>A container image in 60* lines of Go</title>
  <meta name="description" content="*Not really 60 lines"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/containers.jpeg" alt="“Yellow and orange shipping containers stacked on top of each other” by frank mckenna on Unsplash" />
                <figcaption>“Yellow and orange shipping containers stacked on top of each other” by frank mckenna on Unsplash</figcaption> 
            </figure>
            

            <h1>A container image in 60* lines of Go</h1>
            <p class="description" >*Not really 60 lines</p> 

            <p>At Ravelin we build Go binaries, package them into scratch Docker containers and upload them to Google Cloud Registry so we can use them in a GKE cluster. We develop on Mac laptops, so we use Docker for Mac for this. But building and pushing the container images is very slow, particularly if we want to build 44 at once. Given we just want to package up single binaries the process seemed a bit overblown and complicated.</p>
<p>So I thought I’d work out what a docker image actually is, and see if I could build one myself and upload it directly. I wanted a small Go program with few dependencies that could build a very simple container image and upload it.</p>
<h2>So what is a container image?</h2>
<p>I started off thinking a container image is a file that you would construct and upload. This is wrong. A container image is a set of files and a manifest file. For my simple image there are 3 files we need.</p>
<ol>
<li><em>An image layer</em>. This is a tar file containing the files I want in the container. If I had a more complex container it would have multiple layers (tar files) that would be applied one on top of another. But for my simple scratch image a single tar file will do.</li>
<li><em>An image config</em>. This basically corresponds to the bits of your Dockerfile that aren’t concerned with which files are in your layers. So things like labels, environment variables, volumes, etc. It also contains references to the layers in the image. You can find the definitions I used for this here.</li>
<li><em>A manifest</em>. This references the layer file and image config file, tying everything together.</li>
</ol>
<h2>The good thing about standards is there’s so many of them.</h2>
<p>There are several standards for these things. I began by looking at the <a href="https://github.com/opencontainers/image-spec/blob/master/spec.md">Open Container Initiative standards</a>, and that’s nearly where I left it. The OCI documents are extremely difficult to understand, and after quite a bit of work I found they’re not supported by the Docker repository.</p>
<p>So I swapped to the definitions used by Docker, which seem to be documented by code and a string of issues. I decided to copy them out of the docker codebase into my own code to avoid some fairly hefty dependencies, so you can find the definitions here.</p>
<h2>So what do you actually do?</h2>
<ol>
<li>Create a tar file of the contents of your container. Yep, just an ordinary tar file.</li>
<li>Run this tar file through sha256 to get a digest. There’s a nice library to help you do this.</li>
<li>Upload the tar file to the repo as a blob. The layer blob is named after its digest.</li>
<li>Build an image config JSON.</li>
<li>Get the sha256 digest of the JSON.</li>
<li>Upload the JSON to the repo as a blob. The image config blob is named after its digest.</li>
<li>Build the manifest JSON. This references the layer &amp; image config via their digests.</li>
<li>Upload the manifest to the repo. The URL for the manifest includes the image name and tag. If you want multiple tags just upload the manifest again with a different URL.</li>
</ol>
<pre><code class="language-json">{
  &quot;architecture&quot;: &quot;amd64&quot;,
  &quot;os&quot;: &quot;linux&quot;,
  &quot;config&quot;: {
    &quot;Entrypoint&quot;: [
      &quot;/app&quot;
    ]
  },
  &quot;rootfs&quot;: {
    &quot;type&quot;: &quot;layers&quot;,
    &quot;diff_ids&quot;: [
      &quot;sha256:d950580d13e7b6fcbffbbe90129536e1acbf4be04badb50dcc4307c10b4672c7&quot;
    ]
  }
}
</code></pre>
<p>A very simple image config</p>
<pre><code class="language-json">{
  &quot;schemaVersion&quot;: 2,
  &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,
  &quot;config&quot;: {
    &quot;mediaType&quot;: &quot;application/vnd.docker.container.image.v1+json&quot;,
    &quot;size&quot;: 184,
    &quot;digest&quot;: &quot;sha256:51f7917e0550525eda6b4656a3bdf8ddbd084664edb1dc372dd63f55ed52c565&quot;
  },
  &quot;layers&quot;: [
    {
      &quot;mediaType&quot;: &quot;application/vnd.docker.image.rootfs.diff.tar.gzip&quot;,
      &quot;size&quot;: 729097,
      &quot;digest&quot;: &quot;sha256:08c20a47894d73e1f4f672b56ef19ae3f836b799a582732bf995439adf492167&quot;
    }
  ]
}
</code></pre>
<p>A very simple manifest</p>
<h2>How do you upload a blob?</h2>
<p>A blob on Docker Hub has a URL like <code>https://index.docker.io/v2/&lt;image name&gt;/blobs/&lt;digest&gt;</code>. So before you upload a blob you can check whether it’s already present by sending a HEAD request for this URL. If you get a 200 OK, the blob is already uploaded.</p>
<p>If you do need to upload the blob, you first create a new upload with a POST to <code>https://index.docker.io/v2/&lt;image name&gt;/blobs/uploads</code>. This will return a <code>202 ACCEPTED</code> response with a <code>Location</code> header containing the URL to upload the blob to.</p>
<p>Next you upload the blob with a PUT to the URL you’ve received. Add <code>digest=&lt;digest&gt;</code> as a URL query parameter, set the <code>Content-Length</code>, and set the <code>Content-Type</code> to <code>application/octet-stream</code>.</p>
<p>Both the layer tar file and the JSON-encoded image config should be uploaded as blobs.</p>
<h2>How do you upload the manifest?</h2>
<p>The JSON-encoded manifest should be PUT to <code>https://index.docker.io/v2/&lt;image name&gt;/manifests/&lt;tag&gt;</code>. This time the <code>Content-Type</code> should be <code>application/vnd.docker.distribution.manifest.v2+json</code></p>
<h2>What about auth?</h2>
<p>Any of these requests could return a 401 Unauthorised response with a Www-Authenticate header that, for the Docker registry, looks something like the following.</p>
<pre><code class="language-http">Bearer realm=”https://auth.docker.io/token&quot;,service=&quot;registry.docker.io&quot;,scope=&quot;repository:philpearl/test:pull,push&quot;
</code></pre>
<p>This is telling you that you can get a Bearer token by sending a GET to <code>https://auth.docker.io/token?service=registry.docker.io&amp;scope=repository:philpearl/test:pull,push</code>. In the case of Docker you need to send your Docker Hub username and password using Basic Auth.</p>
<p>The response looks something like the following. I’ve edited the tokens in this response.</p>
<pre><code class="language-http">{&quot;token&quot;:&quot;eyJ..snip..&quot;,&quot;access_token&quot;:&quot;eyJ..snap...&quot;,&quot;expires_in&quot;:300,&quot;issued_at&quot;:&quot;2018-04-29T14:50:42.311414998Z&quot;}
</code></pre>
<p>The token field is a Bearer token that can then be used to authorise your requests by adding a header like the following.</p>
<pre><code class="language-http">Authorization: Bearer eyJ..snip..
</code></pre>
<p>If you don’t want to wait for the challenge, you can start by sending a GET to <code>https://index.docker.io/v2/</code>. This will return the <code>WWW-Authenticate</code> header, so you can get a token before attempting any uploads.</p>
<h2>So where’s that 60 lines of Go?</h2>
<p>Ah, well, it’s more like 540 lines, and they’re <a href="https://github.com/philpearl/scratchbuild">here</a>.</p>
<h2>Prior Art</h2>
<p>If what I’ve put together here is too simple for your needs there are quite a few other container image builders that avoid Docker, but allow you to build complex multi-layered images directly from Dockerfiles. Some of the tools below came out very recently, and were basically what started me thinking about this.</p>
<ul>
<li>https://github.com/genuinetools/img</li>
<li>https://github.com/cyphar/orca-build</li>
<li>https://github.com/projectatomic/buildah</li>
<li>https://github.com/projectatomic/skopeo</li>
<li>https://github.com/GoogleContainerTools/kaniko</li>
</ul>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>