<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Go interfaces, but at what cost?</title>
  <meta name="description" content="Interfaces are not without overhead"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/escape.jpg" alt="escape sign" />
                <figcaption>escape sign</figcaption> 
            </figure>
            

            <h1>Go interfaces, but at what cost?</h1>
            <p class="description" >Interfaces are not without overhead</p> 

            <p>There's a cost associated with using interfaces. What is that cost? Let's try and work out some of it.</p>
<p>Let's start with the basic overhead of calling a method via an interface. We'll define a very simple interface with a single method and a very simple implementation. We'll also mark the method so it isn't <a href="https://en.wikipedia.org/wiki/Inline_expansion">inlined</a> by the compiler. We do this so that the call to <code>get</code> isn't completely removed in the direct case.</p>
<pre><code class="language-go">type getter interface {
	get() int
}

type zero struct{}

//go:noinline
func (z zero) get() int {
	return 0
}
</code></pre>
<p>We make a very simple benchmark, with two subtests. One calls <code>get</code> via  a <code>getter</code> the other calls <code>get</code> on the concrete <code>zero</code> type directly.</p>
<pre><code class="language-go">func BenchmarkInterfaceCallSimple(b *testing.B) {
	var z zero
	var g getter
	g = z

	b.Run(&quot;via interface&quot;, func(b *testing.B) {
		total := 0
		for i := 0; i &lt; b.N; i++ {
			total += g.get()
		}

		if total &gt; 0 {
			b.Logf(&quot;total is %d&quot;, total)
		}
	})

	b.Run(&quot;direct&quot;, func(b *testing.B) {
		total := 0
		for i := 0; i &lt; b.N; i++ {
			total += z.get()
		}

		if total &gt; 0 {
			b.Logf(&quot;total is %d&quot;, total)
		}
	})
}
</code></pre>
<p>Here's the result.</p>
<pre><code>BenchmarkInterfaceCallSimple/via_interface-8	4.63 ns/op
BenchmarkInterfaceCallSimple/direct-8       	2.44 ns/op
</code></pre>
<p>So there's a small overhead from making a method call via an interface. So small it won't matter except in extreme cases. Are there any other issues?</p>
<p>Let's try something a little different. We'll create a very simple implementation of io.Reader that fills the buffer with zeros.</p>
<pre><code class="language-go">type zeroReader struct{}

func (z zeroReader) Read(p []byte) (n int, err error) {
	for i := range p {
		p[i] = 0
	}
	return len(p), nil
}
</code></pre>
<p>Our benchmark will follow a very similar structure to the previous one. We'll test calling our implementation via an io.Reader interface and directly.</p>
<pre><code class="language-go">func BenchmarkInterfaceAlloc(b *testing.B) {
	var z zeroReader
	var r io.Reader
	r = z

	b.Run(&quot;via interface&quot;, func(b *testing.B) {
		b.ReportAllocs()

		for i := 0; i &lt; b.N; i++ {
			var buf [7]byte
			r.Read(buf[:])
		}
	})

	b.Run(&quot;direct&quot;, func(b *testing.B) {
		b.ReportAllocs()

		for i := 0; i &lt; b.N; i++ {
			var buf [7]byte
			z.Read(buf[:])
		}
	})
}
</code></pre>
<p>Here's the results. Instead of the approximately 2ns overhead we now have closer to 20ns and 1 allocation. What's going on here?</p>
<pre><code>BenchmarkInterfaceAlloc/via_interface-8   	50000000	    24.5 ns/op	    8 B/op	     1 allocs/op
BenchmarkInterfaceAlloc/direct-8          	300000000	    5.52 ns/op	    0 B/op	     0 allocs/op
</code></pre>
<p>In both cases we allocate a 7 byte buffer before each <code>Read</code> call. In the direct call case, the compiler knows what the implementation of the <code>Read</code> call is, so it can apply <a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">escape analysis</a> and can tell that the buffer does not escape the stack and therefore can be allocated on the stack.</p>
<p>When calling via an interface the implementation is unknown at compile time, therefore the compiler must assume the buffer will escape, and therefore must allocate the buffer on the heap rather than the stack. Allocating on the heap takes longer (and in particular must grab a lock), and will cause more GC overhead.</p>
<p>I find it quite disappointing that any memory passed via any interface will always escape and always require heap memory. In the case of <code>io.Reader</code> the english <a href="https://golang.org/pkg/io/#Reader">definition of the interface</a> strongly hints that the buffer should not escape.</p>
<blockquote>
<p>Implementations must not retain p.</p>
</blockquote>
<p>Similarly the <a href="https://golang.org/pkg/encoding/json/#Unmarshaler"><code>json.Unmarshaler</code> interface description</a> implies the buffer should not actually escape.</p>
<blockquote>
<p>UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.</p>
</blockquote>
<p>Wouldn't it be nice if we could express this on the interface definition in a way the compiler could understand?</p>

        </div>
    </main>
    <footer>
        <p>Â© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>