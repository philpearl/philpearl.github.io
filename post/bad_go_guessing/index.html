<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Bad Go: guessing</title>
  <meta name="description" content="Just write a benchmark"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/guessing.jpg" alt="" />
                
            </figure>
            

            <h1>Bad Go: guessing</h1>
            <p class="description" >Just write a benchmark</p> 

            <p>This is the 5th in a series of posts about Bad Go - a clickbaity title for posts about Go code that I've found frustrating because it could just be that little bit better. Better in my mind means more performant with less impact on GC, without being more complex or harder to read.</p>
<p>In this post I'll rant about a problem I've seen in a number of blog posts. I've seen it more in blog posts than in actual code, but I'm sure people do this with real coding too. They just don't shout about it.</p>
<p>The problem is guessing about performance. This is not good Go. Go has testing and benchmarking built in. Good Go includes benchmarks to prove that performance related changes actually improve things. If you make a performance change and don't have a benchmark that indicates it's an improvement, that's bad Go.</p>
<h2>Bad Blog</h2>
<p>Let's write a bad blog post. We'll write a merge sort, then write another one that we'll claim is better with no proof! We'll claim it's better because it runs in parallel.</p>
<p>Here's our initial merge sort. It takes a slice of integers, splits it in half then calls itself to sort each half. It then merges the two sorted halves together into a final sorted list.</p>
<pre><code class="language-go">func mergeSort(in []int) []int {
	if len(in) &lt;= 1 {
		return in
	}
	mid := len(in) / 2
	sorted1 := mergeSort(in[:mid])
	sorted2 := mergeSort(in[mid:])
	return merge(sorted1, sorted2)
}

// merge zips two sorted slices together
func merge(in1, in2 []int) []int {
	size1, size2 := len(in1), len(in2)
	out := make([]int, size1+size2)

	var idx1, idx2, index int
	for idx1 &lt; size1 &amp;&amp; idx2 &lt; size2 {
		if in1[idx1] &lt; in2[idx2] {
			out[index] = in1[idx1]
			idx1++
		} else {
			out[index] = in2[idx2]
			idx2++
		}
		index++
	}
	for idx1 &lt; size1 {
		out[index] = in1[idx1]
		idx1++
		index++
	}
	for idx2 &lt; size2 {
		out[index] = in2[idx2]
		idx2++
		index++
	}
	return out
}

</code></pre>
<p>The code breaks the problem down into smaller and smaller problems, until at the bottom it's sorting a list of length 1. Then it combines pairs of those length-1 solutions together by zipping together the two sorted lists, then zipping together pairs of larger sorted lists, then pairs of even larger sorted lists until it eventually zips together the sorted versions of the initial split and comes up with a final sorted answer.</p>
<p>Let's start with a quick test to see if it actually sorts the []int.  We'll sort a short list of integers and check the result is as we expected.</p>
<pre><code class="language-go">func TestSort(t *testing.T) {
	vals := []int{
		7, 3, 2, 293, 1, 34, 4, 99,
	}

	sorted := mergeSort(vals)
	assert.Equal(t, []int{1, 2, 3, 4, 7, 34, 99, 293}, sorted)
}
</code></pre>
<p>It passes! Our code can at least sort this one list.</p>
<h2>So parallel!</h2>
<p>We want a parallel version. Since the algorithm splits the initial list in two, the obvious thing to do is to sort those two halves in parallel. Then when we split each of those halves and sort them we'll do each of those further halves in parallel too, and so on right down until we have length 1 lists that don't need sorting.</p>
<p>As we're sorting each half of our slice on a separate goroutine, we'll pass back the sorted data in a channel. Then our merge step will take two sorted streams of ints from incoming channels and produce a merged stream in another output channel.  Each layer in the process will take two sorted channels from the layer below and merge them into a further sorted channel.</p>
<p>Here's our code for the parallel version.</p>
<pre><code class="language-go">func mergeSort2(in []int) []int {
	ch := make(chan int, len(in))
	mergeSortCh(in, ch)

	out := make([]int, 0, len(in))
	for i := range ch {
		out = append(out, i)
	}
	return out
}

func mergeSortCh(in []int, sorted chan int) {
	defer close(sorted)
	if len(in) &lt;= 1 {
		if len(in) == 1 {
			sorted &lt;- in[0]
		}
		return
	}
	mid := len(in) / 2
	sorted1 := make(chan int, mid)
	sorted2 := make(chan int, len(in)-mid)

	// Sort each half concurrently
	go mergeSortCh(in[:mid], sorted1)
	go mergeSortCh(in[mid:], sorted2)

	// Merge the channels
	mergeCh(sorted1, sorted2, sorted)
}

// mergeCh takes two sorted channels of ints in1, in2 and outputs a sorted stream of ints into out
func mergeCh(in1, in2, out chan int) {
	i1, ok1 := &lt;-in1
	i2, ok2 := &lt;-in2
	for ok1 &amp;&amp; ok2 {
		if i1 &lt; i2 {
			out &lt;- i1
			i1, ok1 = &lt;-in1
		} else {
			out &lt;- i2
			i2, ok2 = &lt;-in2
		}
	}
	for ok1 {
		out &lt;- i1
		i1, ok1 = &lt;-in1
	}
	for ok2 {
		out &lt;- i2
		i2, ok2 = &lt;-in2
	}
}
</code></pre>
<p>Nearly all our sorting and merging can take place on goroutines so we must be able to make good use of all our processors. My laptop has 4 cores with hyperthreading so this version will be 4 to 8 times faster.</p>
<p>You believe me don't you?</p>
<h2>I need proof</h2>
<p>OK, OK, let's stop our imaginary bad blog post and go back to my normal entirely immitable style. Of course we're going to write a benchmark!</p>
<p>Regular readers know a benchmark is just a special kind of Go test that runs the code in question N times. The benchmarking framework takes care of deciding on N and doing all the measuring.  For our benchmark we'll take a random permutation of the ints from 0 to 999, and sort it. We'll sort it both with the standard library <code>sort.Ints</code> and our initial <code>mergeSort</code> and the new parallel <code>mergeSort2</code>.</p>
<p>One tricky point is that <code>sort.Int</code> sorts the <code>[]int</code> in place, so to make sure we actually perform the sort for each iteration of the benchmark we need to copy our unsorted slice each time. We'll do this for both the standard library sort and the two merge sorts so we're comparing like with like.</p>
<pre><code class="language-go">func BenchmarkSort(b *testing.B) {
	vals := rand.Perm(1000)
	toSort := make([]int, len(vals))

	b.Run(&quot;std&quot;, func(b *testing.B) {
		b.ReportAllocs()
		for i := 0; i &lt; b.N; i++ {
			copy(toSort, vals)
			sort.Ints(toSort)
		}
	})

	b.Run(&quot;merge&quot;, func(b *testing.B) {
		b.ReportAllocs()
		for i := 0; i &lt; b.N; i++ {
			copy(toSort, vals)
			mergeSort(toSort)
		}
	})

	b.Run(&quot;merge2&quot;, func(b *testing.B) {
		b.ReportAllocs()
		for i := 0; i &lt; b.N; i++ {
			copy(toSort, vals)
			mergeSort2(toSort)
		}
	})
}
</code></pre>
<p>Here are our results. Our first merge sort isn't too bad - a little faster than the standard library sort, but with loads of allocations. The parallel sort is pretty bad. Sorting takes over 6 times longer and there are twice as many allocations as even the merge sort.</p>
<pre><code>std-8    10000   105966 ns/op      32 B/op     1 allocs/op
merge-8  12502    95599 ns/op   81536 B/op   999 allocs/op
merge2-8  1761   664894 ns/op  299926 B/op  2011 allocs/op
</code></pre>
<p>So why doesn't adding goroutines and channels make this faster? Well, for one thing every single int is pushed onto a channel, and <a href="https://medium.com/@philpearl/channel-direct-send-9e2899ab2ee3">last time I measured it</a> that would take ~90ns to transmit something on a channel. With 1000 ints to sort that's already 90,000ns before we've started to sort. And <a href="https://syslog.ravelin.com/goroutine-shoot-out-e47585bebc1f">starting a goroutine</a> takes ~350ns, and with this algorithm we start nearly 2000 of them to sort 1000 ints, so that's 700,000ns. So we've already burned 790,000ns of CPU before we've done anything useful. We do spread this work across processors, but this isn't a sensible approach. Channels and goroutines are great, but they're not magic.</p>
<h2>Bonus round</h2>
<p>If we'd never measured anything we'd never have known whether this version was faster or slower. And we'd never have seen that the first version of our merge does quite so many allocations. Perhaps removing those allocations would be a better first step if we want to improve things?</p>
<p>How could we do that? Well, if you stare hard at this algorithm you'll eventually spot that it splits the original slice into pairs of ints and orders those, then takes pairs of pairs and zips them together so it has several sequences of 4 ordered ints, then takes pairs of those, etc, etc. Awkward to do in place, but we could do it with two slices of ints, zipping ordered pairs of slices from one slice into the other slice, then swapping over.</p>
<p>Here's our code. It looks very different from the original merge sort, but if you think about it long enough you'll realise that from the data point of view it's doing exactly the same thing. We've basically just unrolled the recursive function calls so we can track where the data's going better.</p>
<p>Our two slices of ints are <code>current</code> and <code>next</code>, and we keep swapping between them. <code>stride</code> controls the size of the ordered lists we're zipping together, starting with 1 then doubling each time.</p>
<pre><code class="language-go">func merge3(in []int) []int {
	ll := len(in)
	if ll &lt;= 1 {
		return in
	}

	current := in
	next := make([]int, len(in))
	stride := 1
	for stride &lt; ll {
		end := ll - stride
		for i := 0; i &lt; end; {
			// zip these two together
			idx1, end1 := i, i+stride
			idx2, end2 := end1, i+stride*2
			if end2 &gt; ll {
				end2 = ll
			}

			for idx1 &lt; end1 &amp;&amp; idx2 &lt; end2 {
				if current[idx1] &lt; current[idx2] {
					next[i] = current[idx1]
					idx1++
				} else {
					next[i] = current[idx2]
					idx2++
				}
				i++
			}
			for idx1 &lt; end1 {
				next[i] = current[idx1]
				idx1++
				i++
			}
			for idx2 &lt; end2 {
				next[i] = current[idx2]
				idx2++
				i++
			}
		}
		stride *= 2
		current, next = next, current
	}

	return current
}
</code></pre>
<p>If we feed this into our benchmark we'll see it does reasonably well. It takes about half as long as the standard library or our initial merge sort, and only makes one allocation.</p>
<pre><code>std-8    10000   105966 ns/op      32 B/op     1 allocs/op
merge-8  12502    95599 ns/op   81536 B/op   999 allocs/op
merge2-8  1761   664894 ns/op  299926 B/op  2011 allocs/op
merge3-8 23721    50860 ns/op	 8192 B/op     1 allocs/op
</code></pre>
<p>By running a benchmark we're able to spot a weakness in our original implementation: that it makes a large number of allocations. We have been able to guess at an improvement and been able to confirm the guess really does improve things. So please write benchmarks when you are doing performance work, and newsletter compilers, please don't include performance oriented blog posts that don't provide evidence for their suggestions.</p>
<p>If you're still itching to parallelise a merge sort there are reasonable approaches that result in genuine improvements, and there are good blog posts describing how to do it. <a href="https://hackernoon.com/parallel-merge-sort-in-go-fe14c1bc006">This one</a> is pretty good!</p>
<p>If you've enjoyed this you might enjoy the previous posts in the series. The first two posts are about <a href="https://medium.com/@philpearl/bad-go-slices-of-pointers-ed3c06b8bb41?source=friends_link&amp;sk=9c07548c807cb13ab03a1ad48c047ec2">slices of pointers</a> and <a href="https://medium.com/@philpearl/bad-go-pointer-returns-340f2da8289?source=friends_link&amp;sk=792ed1bf8198e99c08323e3e09e9606d">pointer returns from functions</a>. The third is about <a href="https://medium.com/swlh/bad-go-frivolous-sprintf-2ad28fedf1a0?source=friends_link&amp;sk=3c66aec8cd54f0d727ae14ce111e03ae">frivolous use of fmt.Sprintf</a>. And the fourth tells you why you should <a href="https://medium.com/swlh/bad-go-not-sizing-slices-aed1b01cff83?source=friends_link&amp;sk=e87ad0f46ee0a9d6b1ed55e857ddcd80">size slices</a> where you can.</p>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>