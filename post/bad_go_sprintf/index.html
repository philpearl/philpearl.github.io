<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Bad Go: frivolous Sprintf</title>
  <meta name="description" content="Sprintf is not always fastf"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/sprint.jpg" alt="" />
                
            </figure>
            

            <h1>Bad Go: frivolous Sprintf</h1>
            <p class="description" >Sprintf is not always fastf</p> 

            <p>This is the 3rd in a series of posts about Bad Go - a clickbaity title for posts about Go that I've found frustrating because it could just be that little bit better. Better in my mind is often more performant with less impact on GC without being more complex or harder to read.</p>
<p>The first two posts are about <a href="https://medium.com/@philpearl/bad-go-slices-of-pointers-ed3c06b8bb41">slices of pointers</a> and <a href="https://medium.com/@philpearl/bad-go-pointer-returns-340f2da8289">pointer returns from functions</a></p>
<p>This one is about reaching for <code>fmt.Sprintf</code> to convert types to strings. Things like <code>fmt.Sprintf(&quot;%d&quot;, aNumber)</code> and <code>fmt.Sprintf(&quot;%t&quot;, aBoolean)</code>. Or even worse <code>tag := &quot;working:&quot; + fmt.Sprintf(&quot;%t&quot;, isWorking)</code>.</p>
<p>Is this bad Go? Not really. But it annoys me beyond reason. I should really just chill out and get over it. Before I go and do that, let's go over why it annoys me in excruciating detail.</p>
<p>The reason I don't like this is not just that it is inefficient. It is <em>needlessly</em> inefficient. The more efficient versions are not more difficult to write or to understand.</p>
<p>Why is it inefficient?</p>
<ol>
<li><code>fmt.Sprintf</code> needs to parse its first argument to understand what to do. But in these examples the programmer knows there's just a single very simple task required: convert this number to a string, or this boolean to a string. Why not just do that directly?</li>
<li><code>fmt.Sprintf</code> needs to marshal its variable arguments into a slice of interface{}. The compiler has improved a lot here, but this could cause unnecessary allocations. There are simpler functions for the same task that don't need variable arguments or interface arguments.</li>
<li>But this isn't all bashing <code>fmt.Sprintf</code>. <code>fmt.Sprintf</code> is great. But when you use it, use it. Build the whole string. Don't build tiny pieces and concatenate them. Concatenating strings causes allocations. Allocations are the bane of the life of anyone trying to squeeze performance out of Go.</li>
</ol>
<p>What should we do instead? Well, for that first case <code>fmt.Sprintf(&quot;%d&quot;, aNumber)</code>, we can just replace it with <code>strconv.FormatInt</code>. Let's write a quick benchmark to compare converting a number with <code>fmt.Sprintf</code> and <code>strconv.FormatInt</code>.</p>
<pre><code class="language-go">func BenchmarkSprintfNumber(b *testing.B) {
	b.ReportAllocs()
	vals := make([]string, b.N)
	for i := 0; i &lt; b.N; i++ {
		vals[i] = fmt.Sprintf(&quot;%d&quot;, i)
	}
}

func BenchmarkSprintfStrconvNumber(b *testing.B) {
	b.ReportAllocs()
	vals := make([]string, b.N)
	for i := 0; i &lt; b.N; i++ {
		vals[i] = strconv.FormatInt(int64(i), 10)
	}
}
</code></pre>
<p>Next we run the benchmarks and feed the results into benchstat</p>
<pre><code>go test -run ^$ -bench BenchmarkSprintf -count 8 | tee sprint1.txt
benchstat sprint1.txt 
name                    time/op
SprintfNumber-8          133ns ± 2%
SprintfStrconvNumber-8  45.1ns ± 2%

name                    alloc/op
SprintfNumber-8          32.0B ± 0%
SprintfStrconvNumber-8   23.0B ± 0%

name                    allocs/op
SprintfNumber-8           2.00 ± 0%
SprintfStrconvNumber-8    0.00   
</code></pre>
<p>So <code>fmt.Sprintf</code> takes quite a bit longer and allocates more memory. I struggle to believe that the <code>strconv.FormatInt</code> case allocates no memory. I think it's doing just under 1 allocation per operation, as it has a lookup table for strings for 0-99 so doesn't allocate in those cases. (and it's an easy exercise for the reader to change the benchmark to use numbers greater than 100 to prove this).</p>
<p>The <code>fmt.Sprintf</code> case is already benefitting from lots of compiler cleverness. The function takes variable <code>interface{}</code> arguments, so in previous versions of the compiler there would be an allocation for the slice to carry the arguments and an allocation to convert the integer argument to an <code>interface{}</code>. That doesn't seem to be the case anymore and the difference between these two options used to be starker in earlier versions of Go.</p>
<p>What about <code>fmt.Sprintf(&quot;%t&quot;, aBoolean)</code>? Well, in this case the difference is pretty stark. <code>fmt.Sprintf</code> has all kinds of work to do and <code>strconv.FormatBool</code> is an extremely simple function. We can see the difference in some simple benchmarks.</p>
<pre><code class="language-go">func BenchmarkBoolSprintf(b *testing.B) {
	b.ReportAllocs()
	vals := make([]string, b.N)
	for i := 0; i &lt; b.N; i++ {
		vals[i] = fmt.Sprintf(&quot;%t&quot;, i&amp;1 == 0)
	}
}

func BenchmarkBoolStrconv(b *testing.B) {
	b.ReportAllocs()
	vals := make([]string, b.N)
	for i := 0; i &lt; b.N; i++ {
		vals[i] = strconv.FormatBool(i&amp;1 == 0)
	}
}
</code></pre>
<p>Here are the results - <code>strconv.FormatBool</code> wins hands down.</p>
<pre><code>name           time/op
BoolSprintf-8  85.9ns ± 7%
BoolStrconv-8  14.0ns ± 5%

name           alloc/op
BoolSprintf-8   24.0B ± 0%
BoolStrconv-8   16.0B ± 0%

name           allocs/op
BoolSprintf-8    1.00 ± 0%
BoolStrconv-8    0.00     
</code></pre>
<p>Finally, why do I find <code>tag := &quot;working:&quot; + fmt.Sprintf(&quot;%t&quot;, isWorking)</code> so particularly annoying? Well, what if we wrote <code>tag := fmt.Sprintf(&quot;working:%t&quot;, isWorking)</code>? That's using <code>fmt.Sprintf</code> as it is supposed to be used - to build moderately complex strings. Isn't that just much nicer? And it doesn't incur an extra allocation concatenating the two strings.</p>
<p><code>fmt.Sprintf</code> used like that doesn't make me angry. But for a really hot loop there's a more efficient way. It's a bool so there are only two options for the strings required. So we could write the following.</p>
<pre><code class="language-go">var tag string
if isWorking {
	tag = &quot;working:true&quot;
} else {
	tag = &quot;working:false&quot;
}
</code></pre>
<p>We can compare these three approaches with some simple benchmarks.</p>
<pre><code class="language-go">func BenchmarkBoolTagSprintfAdd(b *testing.B) {
	b.ReportAllocs()
	vals := make([]string, b.N)
	for i := 0; i &lt; b.N; i++ {
		vals[i] = &quot;working:&quot; + fmt.Sprintf(&quot;%t&quot;, i&amp;1 == 0)
	}
}

func BenchmarkBoolTagSprintf(b *testing.B) {
	b.ReportAllocs()
	vals := make([]string, b.N)
	for i := 0; i &lt; b.N; i++ {
		vals[i] = fmt.Sprintf(&quot;working:%t&quot;, i&amp;1 == 0)
	}
}

func BenchmarkBoolTagIf(b *testing.B) {
	b.ReportAllocs()
	vals := make([]string, b.N)
	for i := 0; i &lt; b.N; i++ {
		isWorking := i&amp;1 == 0
		if isWorking {
			vals[i] = &quot;working:true&quot;
		} else {
			vals[i] = &quot;working:false&quot;
		}
	}
}
</code></pre>
<p>And here are the results (again run 8 times and fed through benchstat).</p>
<pre><code>name                 time/op
BoolTagSprintfAdd-8   133ns ± 3%
BoolTagSprintf-8      106ns ± 2%
BoolTagIf-8          13.4ns ± 5%

name                 alloc/op
BoolTagSprintfAdd-8   40.0B ± 0%
BoolTagSprintf-8      32.0B ± 0%
BoolTagIf-8           16.0B ± 0%

name                 allocs/op
BoolTagSprintfAdd-8    2.00 ± 0%
BoolTagSprintf-8       1.00 ± 0%
BoolTagIf-8            0.00     
</code></pre>
<p>All these results are in nanoseconds, so really none of this matters terribly much by itself. But all these inefficiencies will eventually add up, so why not use the more efficient versions? They aren't harder to read or to write. And if your code somehow eventually ends up at the heart of a massive machine learning pipeline, it won't cause nearly as much grief!</p>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>