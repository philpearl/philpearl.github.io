<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Search for a new JSON: jsoniter</title>
  <meta name="description" content="Why did nobody tell me about this?"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/grail.jpg" alt="gotta find that grail" />
                <figcaption>gotta find that grail</figcaption> 
            </figure>
            

            <h1>Search for a new JSON: jsoniter</h1>
            <p class="description" >Why did nobody tell me about this?</p> 

            <p>Both of my regular readers may be wondering what happened after my <a href="https://philpearl.github.io/post/json_own_way/">last blog</a> about potentially forking encoding/json. Did I fork it? No I didn't.</p>
<p>This is partly because I discovered https://github.com/json-iterator/go, which looks like it is the JSON library I was looking for. And partly because I spent my enthusiasm writing <a href="https://github.com/philpearl/plenc">plenc</a> - a serialisation library based around the protobuf wire protocol that bases message definitions on Go structures instead of .proto files. But I'll save talking about plenc for a future post.</p>
<p>But today we're going to talk about jsoniter. jsoniter is a fabulous JSON library that goes out of its way to discourage you from using it. For one thing it isn't really clear about its name. Is it json-iterator or jsoniter? And if you look at github it looks like it's 'just' a Go version of an older Java library. And Java == bad right? And I don't want to iterate my JSON, I want to encode and decode it.</p>
<p>If you move past that and start reading the docs there are some heavy hints that it does what we want.</p>
<blockquote>
<p>Package jsoniter implements encoding and decoding of JSON as defined in RFC 4627 and provides interfaces with identical syntax of standard lib encoding/json. Converting from encoding/json to jsoniter is no more than replacing the package with jsoniter and variable type declarations (if any). jsoniter interfaces gives 100% compatibility with code using standard lib.</p>
</blockquote>
<p>So it looks very much like we can just drop in jsoniter and we'll get better performance. Does it really offer the performance and convenience I'm after? I'll write some benchmarks using the kind of structs we use at <a href="https://www.ravelin.com/careers">Ravelin</a>. And compare encoding/json (from Go 1.14) with jsoniter.</p>
<h2>Benchmark</h2>
<p>Here are the benchmarks. Apologies for the length. We'll test with a struct that contains fields that have custom Marshalers and Unmarshalers. These are the types of fields that we've had performance issues with using encoding/json.</p>
<pre><code class="language-go">package badgo

import (
	&quot;encoding/json&quot;
	&quot;testing&quot;
	&quot;time&quot;

	jsoniter &quot;github.com/json-iterator/go&quot;
	&quot;github.com/unravelin/null&quot;
)

type myteststruct struct {
	A null.Int
	B time.Time
	C time.Time
	D null.String
}

func BenchmarkEncodeMarshaler(b *testing.B) {
	m := myteststruct{
		A: null.IntFrom(42),
		B: time.Now(),
		C: time.Now().Add(-time.Hour),
		D: null.StringFrom(`hello`),
	}

	b.Run(&quot;encoding/json&quot;, func(b *testing.B) {
		b.ReportAllocs()
		b.RunParallel(func(pb *testing.PB) {
			for pb.Next() {
				if _, err := json.Marshal(&amp;m); err != nil {
					b.Fatal(&quot;Encode:&quot;, err)
				}
			}
		})
	})

	b.Run(&quot;jsoniter&quot;, func(b *testing.B) {
		b.ReportAllocs()
		var json = jsoniter.ConfigCompatibleWithStandardLibrary
		b.RunParallel(func(pb *testing.PB) {
			for pb.Next() {
				if _, err := json.Marshal(&amp;m); err != nil {
					b.Fatal(&quot;Encode:&quot;, err)
				}
			}
		})
	})
}

func BenchmarkDecodeMarshaler(b *testing.B) {
	m := myteststruct{
		A: null.IntFrom(42),
		B: time.Now(),
		C: time.Now().Add(-time.Hour),
		D: null.StringFrom(`hello`),
	}

	data, err := json.Marshal(&amp;m)
	if err != nil {
		b.Fatal(err)
	}

	b.Run(&quot;encoding/json&quot;, func(b *testing.B) {
		b.ReportAllocs()
		b.RunParallel(func(pb *testing.PB) {
			var n myteststruct
			for pb.Next() {
				if err := json.Unmarshal(data, &amp;n); err != nil {
					b.Fatal(err)
				}
			}
		})
	})

	b.Run(&quot;jsoniter&quot;, func(b *testing.B) {
		b.ReportAllocs()
		var json = jsoniter.ConfigCompatibleWithStandardLibrary
		b.RunParallel(func(pb *testing.PB) {
			var n myteststruct
			for pb.Next() {
				if err := json.Unmarshal(data, &amp;n); err != nil {
					b.Fatal(err)
				}
			}
		})
	})
}

</code></pre>
<p>And the results? Well, jsoniter is a little faster but has more allocations for both encoding and decoding. Not the result I was hoping for. But we didn't really expect things to be quite that easy.</p>
<pre><code>EncodeMarshaler/encoding/json-16  342ns ± 8%
EncodeMarshaler/jsoniter-16       252ns ± 4%
DecodeMarshaler/encoding/json-16  506ns ± 2%
DecodeMarshaler/jsoniter-16       472ns ± 2%

name                              allocs/op
EncodeMarshaler/encoding/json-16   6.00 ± 0%
EncodeMarshaler/jsoniter-16        7.00 ± 0%
DecodeMarshaler/encoding/json-16   9.00 ± 0%
DecodeMarshaler/jsoniter-16        16.0 ± 0%
</code></pre>
<p>Let's try to improve things. To improve we need to know where these allocations are coming from. We can quickly run a profile.</p>
<pre><code>go test -bench 'BenchmarkEncodeMarshaler/jsoniter' -run ^$ -memprofile mem.prof
go tool pprof -http :6060 post.test mem.prof
</code></pre>
<p>Switching to the <code>alloc_objects</code> samples we can quickly see where most of the allocations are happening. It's in our <a href="https://philpearl.github.io/post/badgo_json/">old favourite</a> (Un)Marshaler methods. I'm going to hope there's a jsoniter way of dealing with these that we can apply with a little effort.</p>
<p><img src="/post/pprof1.png" alt="profile"></p>
<p>If you stare at the documentation extremely hard you'll eventually spot that jsoniter has a very powerful mechanism for writing Encoders and Decoders for any type. These codecs don't have to be methods of the types being encoded/decoded, which means you can create custom marshallers for types that are parts of other packages. So you can directly create custom marshallers and unmarshallers for time.Time for example. This is a complete game-changer. It allows total flexibility.</p>
<p>Here's a codec for time.Time that implements both jsoniter.ValEncoder and jsoniter.ValDecoder interfaces.</p>
<pre><code class="language-go">type timeCodec struct{}

func (timeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*time.Time)(ptr).IsZero()
}

func (timeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	t := (*time.Time)(ptr)

	var scratch [len(time.RFC3339Nano) + 2]byte
	b := t.AppendFormat(scratch[:0], `&quot;`+time.RFC3339Nano+`&quot;`)
	stream.Write(b)
}

func (timeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*time.Time)(ptr) = time.Time{}
		return
	case jsoniter.StringValue:
		ts := iter.ReadStringAsSlice()

		t, err := time.Parse(time.RFC3339Nano, *(*string)(unsafe.Pointer(&amp;ts)))
		if err != nil {
			iter.ReportError(&quot;decode time&quot;, err.Error())
			return
		}

		*(*time.Time)(ptr) = t
	default:
		iter.ReportError(&quot;decode time.Time&quot;, &quot;unexpected JSON type&quot;)
	}
}
</code></pre>
<p>You register the codec with jsoniter as follows. The name you register with is the <a href="https://github.com/modern-go/reflect2">reflect2</a> type name - <code>reflect2.TypeOf(time.Time{}).String()</code>.</p>
<pre><code class="language-go">jsoniter.RegisterTypeEncoder(&quot;time.Time&quot;, timeCodec{})
jsoniter.RegisterTypeDecoder(&quot;time.Time&quot;, timeCodec{})
</code></pre>
<p>Being able to create encoders and decoders for third-party types is a huge improvement over the json.Marshaler and json.Unmarshaler in the standard encoding/json. It gives you much more flexibility. You can improve on the marshalling of standard library types like time.Time without needing to make changes to the library.</p>
<p>Anyway, back to performance. Once I've created codecs for time.Time, null.String and null.Int the benchmarks improve considerably. Now jsoniter looks much more attractive than encoding/json.</p>
<pre><code>name                              time/op
EncodeMarshaler/encoding/json-16  343ns ± 9%
EncodeMarshaler/jsoniter-16       160ns ± 3%
DecodeMarshaler/encoding/json-16  506ns ± 1%
DecodeMarshaler/jsoniter-16       172ns ± 4%

name                              allocs/op
EncodeMarshaler/encoding/json-16   6.00 ± 0%
EncodeMarshaler/jsoniter-16        2.00 ± 0%
DecodeMarshaler/encoding/json-16   9.00 ± 0%
DecodeMarshaler/jsoniter-16        1.00 ± 0%
</code></pre>
<p>jsoniter's documentation is incomplete and it has a confusing name, but if you fight your way through that you'll find a high-performance, high-quality JSON library that's a drop-in replacement for encoding/json without needing any code generation. So if I spend any more energy on JSON in Go I think I'll try contributing documentation to jsoniter.</p>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>