<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Bad Go: slices of pointers</title>
  <meta name="description" content="Please don&#39;t"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/slice.jpg" alt="" />
                
            </figure>
            

            <h1>Bad Go: slices of pointers</h1>
            <p class="description" >Please don&#39;t</p> 

            <p>This is the first of what may be a series of blog posts on uses of Go that I've found frustrating. They're mostly minor things that could just be <em>better</em> without being more complicated. I'm going to try to not only explain why they are bad but also demonstrate it.</p>
<p>First up is slices of pointers. Things like <code>[]*MyStruct</code>. Unless you need to express that certain indices in the slice are nil, then this is just wasteful and <code>[]MyStruct</code> is better in almost all circumstances.</p>
<p>Let's start with some benchmarks. Here's the struct we're going to use.</p>
<pre><code class="language-go">type MyStruct struct {
	A int
	B int
}
</code></pre>
<p>First we'll benchmark building a slice of 100 entries, each of which is a pointer to a MyStruct. We'll fill in some fields in the struct just for laughs.</p>
<pre><code class="language-go">func BenchmarkSlicePointers(b *testing.B) {
	b.ReportAllocs()

	for i := 0; i &lt; b.N; i++ {
		slice := make([]*MyStruct, 0, 100)
		for j := 0; j &lt; 100; j++ {
			slice = append(slice, &amp;MyStruct{A: j, B: j + 1})
		}
	}
}
</code></pre>
<p>Next we'll do the same, but use a <code>[]MyStruct</code>.</p>
<pre><code class="language-go">func BenchmarkSliceNoPointers(b *testing.B) {
	b.ReportAllocs()

	for i := 0; i &lt; b.N; i++ {
		slice := make([]MyStruct, 0, 100)
		for j := 0; j &lt; 100; j++ {
			slice = append(slice, MyStruct{A: j, B: j + 1})
		}
	}
}
</code></pre>
<p>We run the benchmarks with <code>go test -bench . -count 10 &gt; run1.txt</code>, then analyse the results with <code>benchstat run1.txt</code>. Here are the results.</p>
<pre><code>name               time/op
SlicePointers-8    2.50µs ± 2%
SliceNoPointers-8   117ns ± 1%

name               alloc/op
SlicePointers-8    1.60kB ± 0%
SliceNoPointers-8   0.00B     

name               allocs/op
SlicePointers-8       100 ± 0%
SliceNoPointers-8    0.00     
</code></pre>
<p>The no-pointer version allocates less memory, performs fewer allocations and is over an order of magnitude faster.</p>
<p>Why is it faster? Well, the pointer version allocates a new piece of memory for each entry in the slice, whereas the non-pointer version simply fills in the A &amp; B ints in the slice entry itself. Allocating memory takes time - somewhere around 25ns per allocation - and hence the pointer version must take ~2500ns to allocate 100 entries.</p>
<p>Are there any downsides? Not really.</p>
<h2>But I want to change entries in the slice!</h2>
<p>You can still do this with a non-pointer slice. You can obtain a pointer to an entry in the slice and change it.</p>
<pre><code class="language-go">e := &amp;slice[37]
e.A = 42
</code></pre>
<h2>But I really need a slice of pointers to pass to this library</h2>
<p>OK, sometimes you're forced to use a slice of pointers because that's what a library needs. If you can't change the library then perhaps you just do need to build a slice of pointers. You might still be better off using a slice of non-pointers to do this! First build up the slice of non-pointers, then build a slice of pointers from that. You'll likely end up with fewer allocations overall.</p>
<p>We can benchmark this too.</p>
<pre><code class="language-go">func BenchmarkSliceHybrid(b *testing.B) {
	b.ReportAllocs()

	for i := 0; i &lt; b.N; i++ {
		slice := make([]MyStruct, 0, 100)
		for j := 0; j &lt; 100; j++ {
			slice = append(slice, MyStruct{A: j, B: j + 1})
		}

		slicep := make([]*MyStruct, len(slice))
		for j := range slice {
			slicep[j] = &amp;slice[j]
		}
	}
}
</code></pre>
<pre><code>name           time/op
SliceHybrid-8   349ns ± 0%

name           alloc/op
SliceHybrid-8  1.79kB ± 0%

name           allocs/op
SliceHybrid-8    1.00 ± 0%
</code></pre>
<p>This time we don't have to make a fresh allocation for each slice entry in the <code>[]*MyStruct</code> - we just use pointers to the entries in <code>[]MyStruct</code>. The amount of memory allocated it about the same, but it's done in many fewer allocations.</p>
<h2>But my function returns a *MyStruct</h2>
<p>Does it have to? Could you change it to return a <code>MyStruct</code> instead?</p>
<h2>But ... it's complicated!?</h2>
<p>Remember this is just a suggestion. If your case is complicated perhaps you can write a benchmark to see whether changing things will make a worthwhile improvement. I'm just saying that perhaps <code>[]MyStruct</code> should be the normal case, and you should use slices of pointers only where they are necessary.</p>
<p>I'm kind of hoping and kind of dreading that no-one out in the world uses slices of pointers, and therefore this post has fallen completely flat. I hestitate to say let me know on twitter...</p>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>