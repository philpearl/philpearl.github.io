<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>bytes.Buffer revisited</title>
  <meta name="description" content="Always be benchmarking"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            

            <h1>bytes.Buffer revisited</h1>
            <p class="description" >Always be benchmarking</p> 

            <p>Two years ago I wrote a <a href="https://syslog.ravelin.com/bytes-buffer-i-thought-you-were-my-friend-4148fd001229">post about building up strings with bytes.Buffer</a>. I wondered what’s changed over the past two years?</p>
<p>Here are the benchmarks taken from the original post.</p>
<pre><code>BenchmarkCopyKey-8            114 ns/op     31 B/op      1 allocs/op
BenchmarkSimpleKey-8          141 ns/op     31 B/op      1 allocs/op
BenchmarkSimpleMultilineKey-8 256 ns/op     63 B/op      4 allocs/op
BenchmarkSprintfKey-8         392 ns/op     79 B/op      4 allocs/op
BenchmarkJoinKey-8            156 ns/op     63 B/op      2 allocs/op
BenchmarkBufferKey-8          268 ns/op    175 B/op      3 allocs/op
BenchmarkSimpleBufferKey-8    265 ns/op    143 B/op      2 allocs/op
</code></pre>
<p>If we run the same benchmarks with the latest version of Go — 1.11</p>
<pre><code>BenchmarkCopyKey-8           64.4 ns/op     31 B/op      1 allocs/op
BenchmarkSimpleKey-8         85.3 ns/op     31 B/op      1 allocs/op
BenchmarkSimpleMultilineKey-8 190 ns/op     63 B/op      4 allocs/op
BenchmarkSprintfKey-8         280 ns/op     79 B/op      4 allocs/op
BenchmarkJoinKey-8           94.8 ns/op     31 B/op      1 allocs/op
BenchmarkBufferKey-8          194 ns/op    175 B/op      3 allocs/op
BenchmarkSimpleBufferKey-8    164 ns/op    143 B/op      2 allocs/op
</code></pre>
<p>Every option is considerably faster than before! The <code>strings.Join</code> version has one less allocation. Presumably the compiler has improved and one of the allocations has been optimised away or is now kept on the stack.</p>
<p>There is now a new option for building strings — <code>strings.Builder</code>. This appears to be aimed precisely at this use-case. We can build our key as follows.</p>
<pre><code class="language-go">w := strings.Builder{}
w.Grow(len(itemType) + len(clientId) + len(id) + 2)
w.WriteString(itemType)
w.WriteRune(':')
w.WriteString(clientId)
w.WriteRune(':')
w.WriteString(id)
key := w.String()
</code></pre>
<p>This turns out to be as fast as our fastest option.</p>
<pre><code>BenchmarkStringBuilderKey-8  69.6 ns/op     31 B/op      1 allocs/op
</code></pre>
<p>So, <code>bytes.Buffer</code> still isn’t your friend for this use-case. Just use + in simple cases, and reach for <code>strings.Builder</code> in more complex cases.</p>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>