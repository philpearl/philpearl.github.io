<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Nil versus empty slices</title>
  

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/vacuum.jpg" alt="JD Hancock. The Lonely Vacuum of Space. https://www.flickr.com/photos/jdhancock/8955273266 https://creativecommons.org/licenses/by/2.0/" />
                <figcaption>JD Hancock. The Lonely Vacuum of Space. https://www.flickr.com/photos/jdhancock/8955273266 https://creativecommons.org/licenses/by/2.0/</figcaption> 
            </figure>
            

            <h1>Nil versus empty slices</h1>
            

            <p>Go can have nil slices and empty slices, and they're different. What's up with that?</p>
<p>Regular readers of my blog (a select group if ever there was one) will know by now that a slice is syntactic sugar for a struct with a Data pointer, a Length and a Capacity. There's a definition of this struct in <a href="https://golang.org/pkg/reflect/#SliceHeader">reflect</a>. It looks like this.</p>
<pre><code class="language-go">type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
</code></pre>
<p>When a slice is nil all the fields of the slice header are empty. If you create a non-nil slice with zero capacity the Data field is populated. Thus you can tell the difference between a nil slice and an empty slice. Which I guess is useful if you want to tell the difference between a slice being empty versus not present. Here's some code to show how you could check this. (<a href="https://play.golang.org/p/D3nl5lImdcT">playground</a>)</p>
<pre><code class="language-go">    var nilSlice []byte
    emptySlice := []byte{}

    fmt.Println(nilSlice == nil)
    fmt.Println(emptySlice == nil)
</code></pre>
<p>Here's another short program that shows the content of the Slice header for various byte slices (<a href="https://play.golang.org/p/PIuDJyVI-iW">on the playground</a>)</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;reflect&quot;
	&quot;unsafe&quot;
)

func main() {
	printSlice(nil)
	printSlice([]byte{})
	printSlice(make([]byte, 7, 43))
	printSlice(make([]byte, 0, 2))
	printSlice(make([]byte, 0, 0))	
}

func printSlice(s []byte) {
	sh := *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s))
	fmt.Printf(&quot;%#v\n&quot;, sh)
}
</code></pre>
<p>The output is as follows.</p>
<pre><code>reflect.SliceHeader{Data:0x0, Len:0, Cap:0}
reflect.SliceHeader{Data:0xc0000a2f4b, Len:0, Cap:0}
reflect.SliceHeader{Data:0xc0000a2f4d, Len:7, Cap:43}
reflect.SliceHeader{Data:0xc0000a2f4b, Len:0, Cap:2}
reflect.SliceHeader{Data:0xc0000a2f4b, Len:0, Cap:0}
</code></pre>
<p>Note in this case that all the zero capacity slices have the same address for their backing data. This is OK as you can never write to that address via these slices. If you did try to append to the slices you'd exceed the capacity and the backing array would be replaced. You'll also notice that the address is shared with the capacity 2 slice. This is OK for that same reason: any change to the capacity 2 slice would be irrelevant to the zero-capacity slices, and any change to the zero capacity slices would change the address of their backing array.</p>
<p>Is there any penalty for using an empty slice as opposed to a nil slice? Not really. Although in the empty slice case the runtime needs to provide a data pointer, it uses either an arbitrary address on the stack if the slice does not <a href="https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html">escape the stack</a> or the address of a specific global variable (<a href="https://github.com/golang/go/blob/a9f8f02f3cfba18501669cdf58ae75ca36a4cff0/src/runtime/malloc.go#L907">runtime.zerobase</a>) in the case it does escape. There's is a little bit more code run creating the slice in this latter case. Calling into the runtime to get the address to use requires some more instructions than simply setting the Data pointer to nil. But when I tried to measure this overhead it was less than a nanosecond. Nothing to worry about except in the extremest of cases.</p>
<p>I think I prefer nil slices, but on closer inspection it's crazy to have a preference.</p>

        </div>
    </main>
    <footer>
        <p>Â© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>