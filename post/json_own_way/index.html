<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Rebel Go: Forking encoding/json</title>
  <meta name="description" content="What happens when I&#39;m left alone for too long"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/fork.jpg" alt="" />
                
            </figure>
            

            <h1>Rebel Go: Forking encoding/json</h1>
            <p class="description" >What happens when I&#39;m left alone for too long</p> 

            <p>So in my mind the <a href="https://github.com/golang/go/issues/34701">conversation</a> went a little like this.</p>
<p><strong>Phil</strong>: I'd like to make encoding/json better. I'd like to save allocations when marshaling by adding a <a href="https://philpearl.github.io/post/badgo_json/">new interface</a> for custom marshalers.</p>
<p><strong>World</strong>: Given that this can be explored in 3rd-party packages easily, this seems like a likely decline. Leaving open for a week for final comments.</p>
<p><strong>Phil</strong>: Oh, interesting, what would a successful exploration look like?</p>
<p><strong>World</strong>: One consequence of writing your own package is that you could use it and would not need the change in the standard library.</p>
<p><strong>Phil</strong>: Did you just tell me to go <em>fork</em> myself?</p>
<p><strong>World</strong>: <a href="http://b.z19r.com/post/did-you-just-tell-me-to-go-fuck-myself">I believe I did Bob</a>.</p>
<p>I'm really not sure I want to fork encoding/json. I'm not even sure how I would fork part of a repo, or at least not in a way where I could easily merge upstream fixes. And I'd be shocked if anyone would use it. It would likely be a sad and lonely orphan. Why create something with such a miserable fate?</p>
<p>Why? Well, basically because it's Saturday, <a href="https://twitter.com/lizrice">@lizrice</a> has left for a conference and I don't have anything much else to do.</p>
<p>I'm not going to start with a fork. I'll just create a branch and show what the changes would involve, and what the improvements would be. As ever, I'll start with a benchmark.</p>
<p>At <a href="https://www.ravelin.com">Ravelin</a> we pass around a lot of JSON, and that JSON includes fields that are <a href="https://golang.org/pkg/time/#Time.MarshalJSON"><code>time.Time</code></a>. We also made a decision many years ago to use <a href="https://github.com/guregu/null"><code>https://github.com/guregu/null</code></a> to express null values. Now, at this point none of those decisions look the best. If we started from scratch I'm not sure I'd use JSON, or ever use <code>time.Time</code> as the primary method of dealing with time, or use <code>https://github.com/guregu/null</code>, but at this point these decisions are very hard to reverse.</p>
<p>So let's have a benchmark that reflects these decisions. We'll marshal a struct that has a few of these elements in. In reality at Ravelin our structs have many more fields than this, but a great many of the fields are  <code>null.*</code> and <code>time.Time</code> values.</p>
<pre><code class="language-go">func BenchmarkEncodeMarshaler(b *testing.B) {
	b.ReportAllocs()

	m := struct {
		A null.Int
		B time.Time
		C time.Time
		D null.String
	}{
		A: null.IntFrom(42),
		B: time.Now(),
		C: time.Now().Add(-time.Hour),
		D: null.StringFrom(`hello`),
	}

	b.RunParallel(func(pb *testing.PB) {
		enc := json.NewEncoder(ioutil.Discard)

		for pb.Next() {
			if err := enc.Encode(&amp;m); err != nil {
				b.Fatal(&quot;Encode:&quot;, err)
			}
		}
	})
}
</code></pre>
<p>If we run this benchmark with Go 1.13 and run the output through <a href="https://github.com/golang/perf/tree/master/cmd/benchstat">benchstat</a> we get the following. Yes, there are 13 allocations needed to marshal this little struct to JSON.</p>
<pre><code>name               time/op
EncodeMarshaler-8  753ns ± 2%

name               alloc/op
EncodeMarshaler-8   496B ± 0%

name               allocs/op
EncodeMarshaler-8   13.0 ± 0%
</code></pre>
<p>There are already some improvements scheduled for Go 1.14 that get this down to 5 allocations (some from me! <a href="https://philpearl.github.io/post/badgo_json/">post</a>, <a href="https://philpearl.github.io/post/json_good/">post</a>, <a href="https://go-review.googlesource.com/c/go/+/200864">contribution</a>, <a href="https://go-review.googlesource.com/c/go/+/203608">contribution</a>). But with a rough version of the proposed change we can get rid of the allocations altogether. Here's a comparison of the same benchmark at Go tip versus my branch with the changes.</p>
<pre><code>name               old time/op    new time/op    delta
EncodeMarshaler-8     626ns ± 3%     315ns ± 1%   -49.65%  (p=0.000 n=8+7)

name               old alloc/op   new alloc/op   delta
EncodeMarshaler-8      128B ± 0%        0B       -100.00%  (p=0.000 n=8+8)

name               old allocs/op  new allocs/op  delta
EncodeMarshaler-8      5.00 ± 0%      0.00       -100.00%  (p=0.000 n=8+8)
</code></pre>
<p>This is why I think this is a good idea. Running time is halved and all the allocations have gone. The changes are entirely back-compatible and have taken less than 3 hours so far (including writing this much of the blog post).</p>
<p>So what are the changes? Well, we start by adding a new marshaler interface. The idea here is that the <code>MarshalAppendJSON</code> implementation doesn't need to allocate the <code>[]byte</code> it returns that contains the marshaled JSON. It can build its response by appending to the <code>in</code> slice that encoding/json passes to it. With the current <code>MarshalJSON</code> function that's not true so pretty much every call to a <code>MarshalJSON</code> method results in an allocation.</p>
<pre><code class="language-go">type MarshalAppender interface {
	MarshalAppendJSON(in []byte) ([]byte, error)
}
</code></pre>
<p>Once we have the interface we add some code to identify when it is present for a type and assign the appropriate marshaling function. We need to make sure we use the new <code>MarshalAppender</code> interface in preference to <code>Marshaler</code> whenever it is present.</p>
<pre><code class="language-go">var (
   marshalerType       = reflect.TypeOf((*Marshaler)(nil)).Elem()
   marshalAppenderType = reflect.TypeOf((*MarshalAppender)(nil)).Elem()
   textMarshalerType   = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
)

// newTypeEncoder constructs an encoderFunc for a type.
// The returned encoder only checks CanAddr when allowAddr is true.
func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {
   // If we have a non-pointer value whose type implements
   // Marshaler with a value receiver, then we're better off taking
   // the address of the value - otherwise we end up with an
   // allocation as we cast the value to an interface.
   if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &amp;&amp; reflect.PtrTo(t).Implements(marshalAppenderType) {
   	return newCondAddrEncoder(addrMarshalAppenderEncoder, newTypeEncoder(t, false))
   }
   if t.Implements(marshalAppenderType) {
   	return marshalAppenderEncoder
   }

   if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &amp;&amp; reflect.PtrTo(t).Implements(marshalerType) {
   	return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))
   }
</code></pre>
<p>The final change to make the new interface work is to add some code to call the new method. This follows the pattern set for the existing <code>Marshaler</code>, except we assume <code>MarshalAppender</code> implementations produce valid, compact JSON. The current <code>Marshaler</code> does not assume this, so it calls the <code>compact</code> function on the output. <code>compact</code> validates and compacts the JSON returned from the <code>Marshaler</code>.</p>
<p>I think the better choice is to trust library writers to create proper implementations. We do not need to check the output millions upon billions of times in live running applications. So my implementation below simply copies the result of <code>MarshalAppendJSON</code> into the encoder's buffer.</p>
<pre><code class="language-go">func marshalAppenderEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() {
		e.WriteString(&quot;null&quot;)
		return
	}
	m, ok := v.Interface().(MarshalAppender)
	if !ok {
		e.WriteString(&quot;null&quot;)
		return
	}
	b, err := m.MarshalAppendJSON(e.scratch[:0])
	if err != nil {
		e.error(&amp;MarshalerError{v.Type(), err, &quot;MarshalAppendJSON&quot;})
		return
	}

	// We trust implementers of MarshalAppender to generate valid, maximally compact JSON
	e.Write(b)
}

func addrMarshalAppenderEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	va := v.Addr()
	if va.IsNil() {
		e.WriteString(&quot;null&quot;)
		return
	}
	m := va.Interface().(MarshalAppender)
	b, err := m.MarshalAppendJSON(e.scratch[:0])
	if err != nil {
		e.error(&amp;MarshalerError{v.Type(), err, &quot;MarshalAppendJSON&quot;})
		return
	}

	// We trust implementers of MarshalAppender to generate valid, maximally compact JSON
	e.Write(b)
}
</code></pre>
<p>The next step to make this useful is to implement some custom marshalers. First we'll do <code>time.Time</code>. To me this one is very important - there must be a very large number of folk with <code>time.Time</code> in structs that get marshaled to JSON. The <code>time.AppendFormat</code> function makes this easy to implement.</p>
<pre><code class="language-go">// MarshalAppendJSON implements the json.Marshaler interface.
// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.
func (t Time) MarshalAppendJSON(b []byte) ([]byte, error) {
	if y := t.Year(); y &lt; 0 || y &gt;= 10000 {
		// RFC 3339 is clear that years are 4 digits exactly.
		// See golang.org/issue/4556#c15 for more discussion.
		return nil, errors.New(&quot;Time.MarshalAppendJSON: year outside of range [0,9999]&quot;)
	}

	b = append(b, '&quot;')
	b = t.AppendFormat(b, RFC3339Nano)
	b = append(b, '&quot;')
	return b, nil
}
</code></pre>
<p>Finally for my benchmark I need to create <code>MarshalAppendJSON</code> methods for <code>Int</code> and <code>String</code> from the null package. The <code>Int</code> one is easy because of the <code>strconv.AppendInt</code> function.</p>
<pre><code class="language-go">func (i Int) MarshalAppendJSON(b []byte) ([]byte, error) {
	if !i.Valid {
		return nullLiteral, nil
	}
	return strconv.AppendInt(b, i.Int64, 10), nil
}
</code></pre>
<p>The <code>String</code> version is much more problematic. I need to JSON encode a string value. But if I just call <code>json.Marshal</code> to do this I don't get any performance improvements. Really I'd need to add an efficient <code>EncodeString</code> method to encoding/json. But even without that at least the new interface makes it possible to put in the work and improve performance. Here I've just followed the definition of a JSON string from <a href="http://json.org/">json.org</a> and implemented the encoding myself inline. And it might even be partially correct (it definitely isn't fully correct yet)! And at least it shows that it would be possible to easily implement an efficient <code>EncodeString</code> method.</p>
<pre><code class="language-go">func (s String) MarshalAppendJSON(b []byte) ([]byte, error) {
	if !s.Valid {
		return append(b, nullLiteral...), nil
	}
	b = append(b, '&quot;')
	for i, r := range s.String {
		switch r {
		case '\\', '&quot;':
			b = append(b, '\\', byte(r))
		case '\n':
			b = append(b, '\\', 'n')
		case '\r':
			b = append(b, '\\', 'r')
		case '\t':
			b = append(b, '\\', 't')
		default:
			if r &lt; 32 {
				b = append(b, '\\', 'u', '0', '0', hex[r&gt;&gt;4], hex[r&amp;0xF])
			} else if r &lt; utf8.RuneSelf {
				b = append(b, byte(r))
			} else {
				// append in its natural form
				b = append(b, s.String[i:i+utf8.RuneLen(r)]...)
			} 
		}
	}
	b = append(b, '&quot;')
	return b, nil
}
</code></pre>
<p>That was all that was necessary to remove all allocations from this particular JSON marshaling benchmark. Hopefully I've explained why this is a useful &amp; positive change to make. I think I've also highlighted why it should be done in the standard library. It is only really useful if library writers implement <code>MarshalAppender</code>. And I think they'll only do that if <code>MarshalAppender</code> is part of the defacto JSON library. Certainly I can't imagine the <code>time</code> standard library package will be modified to implement a third-party JSON encoding method!</p>
<p>Dear reader, you've made it this far, but I have another task to ask of you. I want to know whether I should fork encoding/json to add <code>MarshalAppender</code>, and potentially make other changes that aren't going to be acceptable to the Go team. I don't really want to do it just for my own amusement. I only want to do it if people will actually use it. I don't have a voting system, but if this post becomes &quot;popular&quot; (and my standards for popularity are laughably low) then I might just do it. So if you'd like me to make a fork mash that like/retweet/applaud/up-vote button on whatever thing you discovered this post on.</p>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>