<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Bad Go: not sizing slices</title>
  

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/slicesize.jpg" alt="" />
                
            </figure>
            

            <h1>Bad Go: not sizing slices</h1>
            

            <p>This is the 4th in a series of posts about Bad Go - a clickbaity title for posts about Go code that I've found frustrating because it could just be that little bit better. Better in my mind means more performant with less impact on GC, without being more complex or harder to read.</p>
<p>In this post we'll look at a very common issue - not setting the size of a slice when you <em>know</em> how big it needs to be. I'm talking about code like the following.</p>
<pre><code class="language-go">func numbersToStringsBad(numbers []int) []string {
	vals := []string{}
	for _, n := range numbers {
		vals = append(vals, strconv.Itoa(n))
	}
	return vals
}
</code></pre>
<p>Why is this bad? Well, you know that the slice of strings needs to have the same capacity as the slice of ints, so why not save everyone some guesswork and make the slice have the right capacity? Here's a better version. We don't have to do anything particularly different, just set the capacity of the slice to the length of the slice of numbers.</p>
<pre><code class="language-go">func numbersToStringsBetter(numbers []int) []string {
	vals := make([]string, 0, len(numbers))
	for _, n := range numbers {
		vals = append(vals, strconv.Itoa(n))
	}
	return vals
}
</code></pre>
<p>Let's do a quick benchmark and see how bad failing to set the capacity is, and how much we can gain with a little extra care. I've used <code>b.Run</code> to group these two benchmarks together this time.</p>
<pre><code class="language-go">func BenchmarkSliceConversion(b *testing.B) {
	numbers := make([]int, 100)
	for i := range numbers {
		numbers[i] = i
	}

	b.Run(&quot;bad&quot;, func(b *testing.B) {
		b.ReportAllocs()
		for i := 0; i &lt; b.N; i++ {
			numbersToStringsBad(numbers)
		}
	})

	b.Run(&quot;better&quot;, func(b *testing.B) {
		b.ReportAllocs()
		for i := 0; i &lt; b.N; i++ {
			numbersToStringsBetter(numbers)
		}
	})
}
</code></pre>
<p>I ran the benchmarks 8 times each and fed the results to benchstat. Here's the results.</p>
<pre><code>name                      time/op
SliceConversion/bad-8     2.12µs ± 5%
SliceConversion/better-8  1.02µs ± 4%

name                      alloc/op
SliceConversion/bad-8     4.08kB ± 0%
SliceConversion/better-8  1.79kB ± 0%

name                      allocs/op
SliceConversion/bad-8       8.00 ± 0%
SliceConversion/better-8    1.00 ± 0%
</code></pre>
<p>You'll see the better version takes half as much time and does only 1 allocation versus the 8 allocations done by the bad version. Why does this happen? It is all to do with growing the slice to fit the data.</p>
<p>I think we can see what's happening by modifying <code>numbersToStringsBad</code> to show how the capacity of the slice grows as we append more items to it. This modified code prints the capacity of the slice whenever it changes.</p>
<pre><code class="language-go">func numbersToStringsBadInstrumented(numbers []int) []string {
	vals := []string{}
	oldCapacity := cap(vals)
	for _, n := range numbers {
		vals = append(vals, strconv.Itoa(n))
		if capacity := cap(vals); capacity != oldCapacity {
			fmt.Printf(&quot;len(vals)=%d, cap(vals)=%d (was %d)\n&quot;, len(vals), capacity, oldCapacity)
			oldCapacity = capacity
		}
	}
	return vals
}

func main() {
	numbers := make([]int, 100)
	for i := range numbers {
		numbers[i] = i
	}

	numbersToStringsBadInstrumented(numbers)
}
</code></pre>
<p>Here's the output. We can see that <code>append</code> doubles the capacity of the slice each time it fills up.</p>
<pre><code>len(vals)=1, cap(vals)=1 (was 0)
len(vals)=2, cap(vals)=2 (was 1)
len(vals)=3, cap(vals)=4 (was 2)
len(vals)=5, cap(vals)=8 (was 4)
len(vals)=9, cap(vals)=16 (was 8)
len(vals)=17, cap(vals)=32 (was 16)
len(vals)=33, cap(vals)=64 (was 32)
len(vals)=65, cap(vals)=128 (was 64)
</code></pre>
<p>How does the capacity of the slice increase? <code>append</code> increases the slice by allocating a new slice that's twice as big and copying the data over. So as well as the overhead of extra allocations we suffer the overhead of copying the data. And all the intermediate versions of the slice that are discarded will need to be garbage collected too.</p>
<p>Now you know the consequences, you'll size your slices whenever you can won't you? But if you don't know what the final size will be, don't worry. Although the &quot;bad&quot; version is slower, it really isn't that bad.</p>
<p>Since you've read this far, as a bonus let's see if we can do a little bit better if we set the length of the slice as well as the capacity, and set each slice entry directly rather than appending.</p>
<pre><code class="language-go">func numbersToStringsBest(numbers []int) []string {
	vals := make([]string, len(numbers))
	for i, n := range numbers {
		vals[i] = strconv.Itoa(n)
	}
	return vals
}
</code></pre>
<p>benchstat gives us the following. Our final version is faster by about 10%</p>
<pre><code>name                      time/op
SliceConversion/bad-8     2.07µs ± 2%
SliceConversion/better-8  1.00µs ± 2%
SliceConversion/best-8     900ns ± 2%

name                      alloc/op
SliceConversion/bad-8     4.08kB ± 0%
SliceConversion/better-8  1.79kB ± 0%
SliceConversion/best-8    1.79kB ± 0%

name                      allocs/op
SliceConversion/bad-8       8.00 ± 0%
SliceConversion/better-8    1.00 ± 0%
SliceConversion/best-8      1.00 ± 0%
</code></pre>
<p>If you've enjoyed this you might enjoy the previous posts in the series. The first two posts are about <a href="https://medium.com/@philpearl/bad-go-slices-of-pointers-ed3c06b8bb41?source=friends_link&amp;sk=9c07548c807cb13ab03a1ad48c047ec2">slices of pointers</a> and <a href="https://medium.com/@philpearl/bad-go-pointer-returns-340f2da8289?source=friends_link&amp;sk=792ed1bf8198e99c08323e3e09e9606d">pointer returns from functions</a>. The third is about <a href="https://medium.com/swlh/bad-go-frivolous-sprintf-2ad28fedf1a0?source=friends_link&amp;sk=3c66aec8cd54f0d727ae14ce111e03ae">frivolous use of fmt.Sprintf</a>.</p>

        </div>
    </main>
    <footer>
        <p>© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>