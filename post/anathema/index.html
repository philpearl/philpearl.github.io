<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Breaking Printf</title>
  

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/unsafe.jpg" alt="A very unsafe house by Cindy Tang via Unsplash" />
                <figcaption>A very unsafe house by Cindy Tang via Unsplash</figcaption> 
            </figure>
            

            <h1>Breaking Printf</h1>
            

            <p>Acute impostor syndrome. When something you've built, something you're proud of, built against all advice, full of unsafe, goes deeply, horribly wrong. Unspeakably wrong. You've built your company's data pipeline around this code. If it is wrong then everything might be wrong. How could it go so wrong?</p>
<p>Your belief in yourself crumbles away. The ghost of Rob Pike haunts your every waking moment, shreiking &quot;premature optimisation is the root of all evil&quot;.</p>
<p>How wrong exactly? Well, code that you know should print zero, or at worst some reasonably small number, insists on printing a number that matches the time in nanoseconds since first January 1970 at around 9 in the morning on 30th September 2021.</p>
<p>Panic grips as you hear Robert Griesemer whispering &quot;memory corruption&quot;. Ken Thompson is not angry, just disappointed.</p>
<p>But you keep the panic under control and begin to investigate. In the debugger the variable appears to be zero, but it still prints as 163298695000000000. You change the code so it will only print the variable if it is zero. It prints 163298695000000000.</p>
<pre><code class="language-go">	if limited == 0 {
		fmt.Printf(&quot;limited is zero. %d\n&quot;, limited) // Prints 163298695000000000
	}
</code></pre>
<p>Your despair lifts. Even if you've done something very stupid, at least it's <em>interesting</em>.</p>
<p>Here's a minimal reproduction scenario. For what I hope are obvious reasons I've used 42 in place of 163298695000000000.</p>
<pre><code class="language-go">package badgo

import (
	&quot;fmt&quot;
	&quot;unsafe&quot;
)

func run() {
	var limited int
	var out int
	doThing(out, func(out interface{}) {
		if limited == 0 {
			fmt.Printf(&quot;limited is zero. %d\n&quot;, limited) // Prints 42
		}
		limited++
	})
}

//go:noinline
func doThing(out interface{}, f func(out interface{})) {
	p := (*eface)(unsafe.Pointer(&amp;out)).data
	*(*int)(p) = 42
	f(out)
}

type eface struct {
	rtype unsafe.Pointer
	data  unsafe.Pointer
}

</code></pre>
<p>Here's the output.</p>
<pre><code>limited is zero. 42
</code></pre>
<p>The flaw is this bit. Just look at it. It certainly doesn't seem to be rational
or understandable. It's wrong, but it isn't <em>quite</em> as wrong as it looks.</p>
<pre><code class="language-go">    p := (*eface)(unsafe.Pointer(&amp;out)).data
	*(*int)(p) = 42
</code></pre>
<p>What it is doing is using knowledge of the internals of interface types to gain
access to a pointer to the value that the interface represents.
I've talked about the internals of interface types before <a href="https://syslog.ravelin.com/what-is-an-interface-ee67b3cc9e97">here</a>, but let's see if we can go over what's going on.</p>
<p>An interface variable is comprised of two pointers.
You can think of it as syntactic sugar for a struct like the following.</p>
<pre><code class="language-go">type eface struct {
	rtype unsafe.Pointer
	data unsafe.Pointer
}
</code></pre>
<p>The first pointer points to some information about the type of the value contained in the interface.
The second pointer points to the value of the interface.</p>
<p>When you put a pointer type into an interface variable, then the data pointer in the interface variable can simply be the pointer.</p>
<pre><code class="language-go">var a interface{}

i = 7
a = &amp;i
</code></pre>
<p>In this code above, the <code>data</code> pointer within a can simply be a pointer to i.</p>
<p>If you put a non-pointer type in an interface variable then what do you use for the data pointer?
One choice would be to use a pointer to the original variable.
But what would then happen if you changed the original variable?</p>
<pre><code class="language-go">var i int
var a interface{}

i = 7
a = i
i++

fmt.Println(a)
</code></pre>
<p>What would happen to <code>a</code> in this case?
If <code>a</code> contained a pointer to <code>i</code>, then when we change <code>i</code> the contents of <code>a</code> would change, and the code above would print 8, not 7.
This is not what we want, and not what happens if you run the code above.</p>
<p>So Go does not put a pointer to the original value in the interface variable in this case.
Instead it allocates some memory, copies the value into it, then uses the pointer to this newly allocated memory in the interface variable.</p>
<p>That way you can change the original value (<code>i</code> in the case above), and the value in the interface variable (<code>a</code> above) does not change.</p>
<p>So let's go back and look at that dodgy code again.</p>
<pre><code class="language-go">    p := (*eface)(unsafe.Pointer(&amp;out)).data
	*(*int)(p) = 42
</code></pre>
<p><code>out</code> is an interface variable containing an <code>int</code>
All those brackets and unsafe things are retrieving that data pointer from the interface variable.
Which is in this case is a pointer to an <code>int</code>.
And then it writes the value <code>42</code> into it.
That should be fine, right?
As long as we don't care about the original value changing?</p>
<p>Ah, actually, no, it isn't.</p>
<p>As I've described above, putting a non-pointer value in an interface variable causes an allocation so Go can copy the value.
Allocations can be bad for performance.
So Go has some optimisations to avoid some of these allocations.</p>
<p>In particular if you put a small <code>int</code> (&lt;= 255) in an interface variable, Go does not allocate and instead uses a pointer into a statically defined table containing integers 0 to 255.</p>
<p>So when this code runs the data pointer in the <code>out</code> interface variable contains a pointer to the zero entry in this static table.</p>
<pre><code class="language-go">    p := (*eface)(unsafe.Pointer(&amp;out)).data
	*(*int)(p) = 42
</code></pre>
<p>And we overwrite it with 42. :facepalm:</p>
<p>Ah, that's not good.
The next time someone puts an integer variable containing zero into an interface variable, Go will use that entry in the static table again.
Except it now contains 42.
We've made 0 == 42. Sometimes.</p>
<hr>
<p>Winding back a little, I said the flawed code was not 100% wrong.</p>
<ul>
<li>The utterly wrong mistake was using this trick on int types.</li>
<li>The mostly wrong mistake was using this trick on non-pointer types at all.</li>
<li>The rather foolish mistake was using any trick in this very particular case as there's very little upside. We're saving just one allocation in a relatively rare operation.</li>
</ul>
<p>But I'll not say using tricks like this is completely wrong.
The flawed code is in <a href="https://github.com/philpearl/avro">github.com/philpearl/avro</a> (I've not fixed it yet), and that library is riddled with tricks with unsafe.
The unsafe tricks reduced data-processing runs of ~5 hours on 60-plus cores with 95% of the time in GC, to ~24 minutes.</p>
<p>There may be other flaws.
Future changes to Go may cause problems.
The library may be hard to use correctly.
But the risk is worth the reward, despite the heart-stopping moments.</p>

        </div>
    </main>
    <footer>
        <p>Â© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>