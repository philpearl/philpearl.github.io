<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Bad Go: Adventures with JSON marshalling</title>
  <meta name="description" content="Adventures for the indoors"/> 

  <style>
  body{
    font-family: "PT Sans", Helvetica, Arial, sans-serif;
    font-size: 1.2em;
    line-height: 1.5em;
  }
  .description {
    font-size: 1.25em;
    font-weight: 300;
  }
  img {
    max-width: 100%;
  }
  main {
    margin: auto;
    width: 60%;
    padding: 0 1em;
  }
  footer {
    margin: auto;
    width: 60%;
    padding: 0 1em;
    color: gray;
    font-size: 0.8em;
  }
  </style>
</head>
<body>
    <main>
        <div class="post">
            
            <figure>
                <img src="/post/marshal.jpg" alt="" />
                
            </figure>
            

            <h1>Bad Go: Adventures with JSON marshalling</h1>
            <p class="description" >Adventures for the indoors</p> 

            <p>This is a story about encoding/json in the Go standard library. I'm not going to say this is bad Go. That would be heresy. But there is an aspect of marshalling that could be improved. Because it is in the standard library it isn't bad Go, but if you followed the pattern in your own code then that would be a mistake. Outside of the standard library it would lose its magical aura, and it would be bad Go.</p>
<p>My frustration is with the Marshaler interface and the MarshalJSON method. This method makes it pretty much impossible for custom JSON marshalling to be efficient. The inimitable Mr. Cheney has recently warned us about this very issue <a href="https://dave.cheney.net/2019/09/05/dont-force-allocations-on-the-callers-of-your-api">here</a>.</p>
<p>(To be clear, although I did sit next to Mr Cheney at a meetup, and once he did like one of my tweets, that does not mean he in any way endorses this blog or its content)</p>
<p>Let's try to demonstrate the problem.  We'll start by marshalling a very simple struct in a simple benchmark.</p>
<pre><code class="language-go">type mystruct struct {
	A int    `json:&quot;a,omitempty&quot;`
	B string `json:&quot;b,omitempty&quot;`
}

func BenchmarkJSONMarshal(b *testing.B) {
	b.ReportAllocs()
	var data = mystruct{
		A: 42,
		B: &quot;42&quot;,
	}
	for i := 0; i &lt; b.N; i++ {
		_, err := json.Marshal(&amp;data)
		if err != nil {
			b.Errorf(&quot;failed to marshal json. %s&quot;, err)
		}
	}
}
</code></pre>
<pre><code>BenchmarkJSONMarshal-8   3627376    316 ns/op   32 B/op   1 allocs/op
</code></pre>
<p>If we run this we find there's just 1 allocation per marshalling attempt, which is the byte slice containing the marshalled data. It would be nice if we could re-use a slice for this, but one allocation is not too upsetting. And if we really want to we can use an <a href="https://golang.org/pkg/encoding/json/#Encoder">encoder</a> to avoid this.</p>
<p>So what am I complaining about? Well, let's modify our struct a little to add a time.</p>
<pre><code class="language-go">type mystruct struct {
	A int       `json:&quot;a,omitempty&quot;`
	B string    `json:&quot;b,omitempty&quot;`
	C time.Time `json:&quot;c&quot;`
}

func BenchmarkJSONMarshal(b *testing.B) {
	b.ReportAllocs()
	var data = mystruct{
		A: 42,
		B: &quot;42&quot;,
		C: time.Now(),
	}
	for i := 0; i &lt; b.N; i++ {
		_, err := json.Marshal(&amp;data)
		if err != nil {
			b.Errorf(&quot;failed to marshal json. %s&quot;, err)
		}
	}
}
</code></pre>
<pre><code>BenchmarkJSONMarshal-8    981222   1345 ns/op  208 B/op   4 allocs/op
</code></pre>
<p>Suddenly we're making 4 allocations per marshalling attempt! 3 additional allocations because we've added a time. Why would that be? Well, one issue is that the json package does not natively understand time.Time, and marshals it via the Marshaler interface. time.Time implements <a href="https://golang.org/pkg/time/#Time.MarshalJSON">MarshalJSON</a>. This forces an additional allocation because the method is defined to return a <code>[]byte</code> with the marshalled time. There's no mechanism in the API to allow this custom marshaler to append it's data to the data marshalled so far. It needs to allocate a separate slice that it returns (thus forcing a heap allocation), and which the json library then appends to its output.</p>
<p>That explains 1 additional allocation. Why are there 3? Well, we can benchmark Time.MarshalJSON to see what it is doing.</p>
<pre><code class="language-go">func BenchmarkTimeMarshal(b *testing.B) {
	b.ReportAllocs()
	var t time.Time

	for i := 0; i &lt; b.N; i++ {
		_, err := t.MarshalJSON()
		if err != nil {
			b.Errorf(&quot;failed to marshal. %s&quot;, err)
		}
	}
}
</code></pre>
<pre><code>BenchmarkTimeMarshal-8   3400222    378 ns/op   48 B/op   1 allocs/op
</code></pre>
<p>This only creates 1 allocation. So the other 2 must somehow come about within the json package itself, presumably as additional overhead joining up the results.</p>
<p>If we run the benchmark under the profiler we discover the causes of the 4 allocations.</p>
<ol>
<li>The byte slice that holds the final marshalled JSON.</li>
<li>The byte slice Time.MarshalJSON is forced to generate.</li>
<li>Some additional overhead copying the marshalled JSON from Time.MarshalJSON into the result byte slice. This uses json.Compact, which allocates a scanner while it does the copying because it also checks the JSON is valid and ensures insignificant space is removed from the JSON.</li>
<li>To access the Marshaler interface, json uses the reflect package, and in fact creates a new <code>interface{}</code> value pointing to the time value. This somehow causes an allocation.</li>
</ol>
<p>As far as I can tell all 3 of these allocations are currently unavoidable if you use a custom JSON marshaler for a type.</p>
<p>Why do I find this so frustrating? To me the existence of the json.Marshaler interface looks like an escape hatch: a mechanism to do things that are out of the ordinary; to put effort in and improve performance. But it isn't that. It's a garbage chute - use it and you'll end up stuck in a bin covered in garbage.</p>
<ul>
<li>Have lots of timestamps in your data =&gt; covered in garbage</li>
<li>Want to use json.RawMessage to avoid encoding parts of your data =&gt; covered in garbage</li>
<li>Need to express null fields, but want to avoid using pointers so you don't get covered in garbage? Well, you'll do a lot of work and end up covered in garbage.</li>
</ul>
<p>Now, none of this is a problem if you're not marshalling a lot of JSON. But if you are it starts to make Go look like a poor choice. Or you have to look at third-party JSON encoders, which isn't an unreasonable option but is somehow unsatisfying.</p>
<p>How could we improve on this? What if we added a second marshaler interface?</p>
<pre><code class="language-go">type MarshalAppender interface {
    MarshalAppendJSON(buf []byte) ([]byte, error)
}
</code></pre>
<p>Implementers of this interface append their json directly to the <code>buf</code> parameter passed in. We define things so that MarshalAppendJSON must append valid JSON without any redundant white space. Finally we work out why accessing the interface method causes an allocation and fix it. Then we'll have the possibility of allocation-free custom JSON marshalling.</p>
<h2>Is it Bad Go?</h2>
<p>MarshalAppender is perhaps a little more complicated than Marshaler. And simple is often best. But if your code is a fundamental building block, either within your own project or for projects throughout the world, I'd argue it's worth going the extra mile to provide both efficient implementations and APIs that can be used efficiently.</p>
<p>Providing just the simple interface may seem simpler and clearer. But what happens when someone needs that greater efficiency? Either they're stuck, or they create a whole new implementation, or they go to extreme lengths to deal with the garbage collector. You've not reduced the complexity in the world - you've deferred it. And increased it.</p>
<h2>Next steps</h2>
<p>I'm actually going to <a href="https://github.com/golang/go/issues/34701">propose this</a> to the Go team and try to contribute the change. I intend to write about the experience in a future blog. Hopefully it won't be terribly interesting!</p>

        </div>
    </main>
    <footer>
        <p>Â© 2016 - 2023 Phil Pearl. All rights reserved.</p>
    </footer>
</body>