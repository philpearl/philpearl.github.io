<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>programming on Phil Pearl&#39;s Blog</title>
    <link>https://philpearl.github.io/categories/programming/</link>
    <description>Recent content in programming on Phil Pearl&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <lastBuildDate>Fri, 30 Aug 2019 15:30:00 +0000</lastBuildDate>
    
	<atom:link href="https://philpearl.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bad Go: pointer returns</title>
      <link>https://philpearl.github.io/post/bad_go_pointer_returns/</link>
      <pubDate>Fri, 30 Aug 2019 15:30:00 +0000</pubDate>
      
      <guid>https://philpearl.github.io/post/bad_go_pointer_returns/</guid>
      <description>As an old C programmer I struggle with this one: it feels completely normal for functions to return pointers to structs. But I&amp;rsquo;ve a feeling this is bad Go, and that we&amp;rsquo;re normally better off returning struct values. I&amp;rsquo;m going to see if I can prove that returning struct values is just plain better, and that returning pointers is bad Go.
I&amp;rsquo;m going to define a struct that I can vary in size easily.</description>
    </item>
    
    <item>
      <title>Bad Go: slices of pointers</title>
      <link>https://philpearl.github.io/post/bad_go_slice_of_pointers/</link>
      <pubDate>Fri, 30 Aug 2019 09:25:00 +0000</pubDate>
      
      <guid>https://philpearl.github.io/post/bad_go_slice_of_pointers/</guid>
      <description>This is the first of what may be a series of blog posts on uses of Go that I&amp;rsquo;ve found frustrating. They&amp;rsquo;re mostly minor things that could just be better without being more complicated. I&amp;rsquo;m going to try to not only explain why they are bad but also demonstrate it.
First up is slices of pointers. Things like []*MyStruct. Unless you need to express that certain indices in the slice are nil, then this is just wasteful and []MyStruct is better in almost all circumstances.</description>
    </item>
    
    <item>
      <title>Go interfaces, but at what cost?</title>
      <link>https://philpearl.github.io/post/interface_at_what_cost/</link>
      <pubDate>Sat, 06 Jul 2019 15:31:00 +0000</pubDate>
      
      <guid>https://philpearl.github.io/post/interface_at_what_cost/</guid>
      <description>There&amp;rsquo;s a cost associated with using interfaces. What is that cost? Let&amp;rsquo;s try and work out some of it.
Let&amp;rsquo;s start with the basic overhead of calling a method via an interface. We&amp;rsquo;ll define a very simple interface with a single method and a very simple implementation. We&amp;rsquo;ll also mark the method so it isn&amp;rsquo;t inlined by the compiler. We do this so that the call to get isn&amp;rsquo;t completely removed in the direct case.</description>
    </item>
    
    <item>
      <title>The why of Go strings</title>
      <link>https://philpearl.github.io/post/why_of_go_strings/</link>
      <pubDate>Sun, 10 Mar 2019 15:10:27 +0000</pubDate>
      
      <guid>https://philpearl.github.io/post/why_of_go_strings/</guid>
      <description>Regular readers of my blog will all be aware that in Go a string is in fact a struct with a pointer to an area of memory containing the byte content of the string and an integer Len that tells you how many bytes make up the string.
Ever wondered why? Probably not, as it seems “obvious” that you need both the length of the string and the bytes of the string to make a string.</description>
    </item>
    
    <item>
      <title>Further Dangers of Large Heaps in Go</title>
      <link>https://philpearl.github.io/post/danger_large_heap/</link>
      <pubDate>Thu, 15 Nov 2018 19:57:02 +0000</pubDate>
      
      <guid>https://philpearl.github.io/post/danger_large_heap/</guid>
      <description>The latest issue is a problem with the bulk feature extraction process we use at Ravelin (yes, we’re hiring! So if you like Go and you’re anywhere near London drop us a line). For our larger clients we’ve found this process just uses more and more memory, so we keep having to run it on more and more expensive boxes. I presumed it was a memory leak of some kind, so I decided to investigate.</description>
    </item>
    
    <item>
      <title>bytes.Buffer revisited</title>
      <link>https://philpearl.github.io/post/bytes_buffer_revisted/</link>
      <pubDate>Sun, 02 Sep 2018 20:15:18 +0000</pubDate>
      
      <guid>https://philpearl.github.io/post/bytes_buffer_revisted/</guid>
      <description>Two years ago I wrote a post about building up strings with bytes.Buffer. I wondered what’s changed over the past two years?
Here are the benchmarks taken from the original post.
BenchmarkCopyKey-8 114 ns/op 31 B/op 1 allocs/op BenchmarkSimpleKey-8 141 ns/op 31 B/op 1 allocs/op BenchmarkSimpleMultilineKey-8 256 ns/op 63 B/op 4 allocs/op BenchmarkSprintfKey-8 392 ns/op 79 B/op 4 allocs/op BenchmarkJoinKey-8 156 ns/op 63 B/op 2 allocs/op BenchmarkBufferKey-8 268 ns/op 175 B/op 3 allocs/op BenchmarkSimpleBufferKey-8 265 ns/op 143 B/op 2 allocs/op  If we run the same benchmarks with the latest version of Go — 1.</description>
    </item>
    
  </channel>
</rss>